colMeans_safe <- function(X) {
  X <- as.matrix(X)
  if(ncol(X) ==1){
    return(mean(X))
  }
  return(colMeans(X))
}

spORMissing <- function(formula, W, A, Delta, Y, data, mubar1, mubar0, mu1, mu0, pi, G) {
  #W <- c("W1", "W2", "Tcenter")
  #A <- "A"
  #Y <- "Y"
  #Delta <- "Delta"

  n <- nrow(data)
  data <- as.data.frame(data)
  A <- data[, A]
  Y <- data[,Y]
  Y[is.na(Y)] <- 0
  V <- model.matrix(formula, data = data[,W])
  Delta <- data[,Delta]
  W <- data[,W]

  mubar <- ifelse(A==1, mubar1, mubar0)
  mu <- ifelse(A==1, mu1, mu0)
  weights = rep(1, nrow(data))

  h_star <- -1* as.vector((pi*mu1*(1-mu1)) / (pi*mu1*(1-mu1) + (1-pi)*mu0*(1-mu0)))
  H_star <- V*(A + h_star)
  H_star1 <- V*(1 + h_star)
  H_star0 <-  V*h_star

  scale <- apply(V,2, function(v){colMeans_safe(weights*as.vector(mu1*(1-mu1) * mu0*(1-mu0) * pi * (1-pi) / (pi * mu1*(1-mu1) + (1-pi) *mu0*(1-mu0) )) * v*V)})
  scale_inv <- solve(scale)

  EIF1 <- (Delta/G)*weights*H_star%*%scale_inv*as.vector(Y-mubar)
  EIF2 <- weights*H_star%*%scale_inv*as.vector(mubar-mu)
  EIF <- EIF1 + EIF2
  var_initial <- var(EIF)
  print("SES")
  print(sqrt(diag(var(EIF1))))
  print(sqrt(diag(var(EIF2))))
  # Perform targeting step
  ################################
  ##### Targeting Step ###########
  ################################
  converged_flag <- FALSE
  for(i in 1:50) {


    ################################
    ##### Update  Q ###########
    ################################
    for(j in 1:10) {

      h_star <-  as.vector(-(pi*mu1*(1-mu1)) / (pi*mu1*(1-mu1) + (1-pi)*mu0*(1-mu0)))
      H_star <- V*(A + h_star)
      H_star1 <- V*(1 + h_star)
      H_star0 <-  V*h_star
      scale <- apply(V,2, function(v){colMeans_safe(weights*as.vector( mu1*(1-mu1) * mu0*(1-mu0) * pi * (1-pi) / (pi * mu1*(1-mu1) + (1-pi) *mu0*(1-mu0) )) * v*V)})
      scale_inv <- solve(scale)
      var_unscaled <- as.matrix(var(weights*H_star*(Y-mu)))
      var_scaled <-  scale_inv %*% var_unscaled  %*%  t(scale_inv)

      score <- sum(abs(colMeans_safe(weights*H_star%*%scale_inv*as.vector(mubar-mu)) ))
      print("Inner")
      print(score)
      if(abs(score) <= min(0.5,mean(sqrt(diag(var_scaled))))/n){
        break
      }
      offset <- qlogis(mu)
      eps <- coef(suppressWarnings(glm(Y~X-1, family = binomial(), weights = weights, offset = offset, data = list(Y = mubar, X = H_star))))
      mu <- as.vector(plogis(offset +  H_star %*% eps))
      mu0 <- as.vector(plogis(qlogis(mu0) +  H_star0 %*% eps ))
      mu1 <- as.vector(plogis(qlogis(mu1) +  H_star1 %*% eps))
    }

    ################################
    ##### Update mubar ###########
    ################################
    h_star <- as.vector(-(pi*mu1*(1-mu1)) / (pi*mu1*(1-mu1) + (1-pi)*mu0*(1-mu0)))
    H_star <- V*(A + h_star)
    H_star1 <- V*(1 + h_star)
    H_star0 <-  V*h_star

    #scale <- apply(V,2, function(v){colMeans_safe(weights*as.vector( mu1*(1-mu1) * mu0*(1-mu0) * pi * (1-pi) / (pi * mu1*(1-mu1) + (1-pi) *mu0*(1-mu0) )) * v*V)})
    #scale_inv <- solve(scale)
    #var_unscaled <- as.matrix(var(weights*H_star*(Y-mubar)))
    #var_scaled <-  scale_inv %*% var_unscaled  %*%  t(scale_inv)

    offset <- qlogis(mubar)
    eps <- coef(suppressWarnings(glm(Y~X-1, family = binomial(), weights = Delta*weights/G, offset = offset, data = list(Y = Y, X = H_star))))
    mubar <- as.vector(plogis(offset +  H_star %*% eps))
    mubar0 <- as.vector(plogis(qlogis(mubar0) +  H_star0 %*% eps ))
    mubar1 <- as.vector(plogis(qlogis(mubar1) +  H_star1 %*% eps))


    ################################
    ##### Check convergence ###########
    ################################
    h_star <- -1* as.vector((pi*mu1*(1-mu1)) / (pi*mu1*(1-mu1) + (1-pi)*mu0*(1-mu0)))
    H_star <- V*(A + h_star)
    H_star1 <- V*(1 + h_star)
    H_star0 <-  V*h_star

    scale <- apply(V,2, function(v){colMeans_safe(weights*as.vector(mu1*(1-mu1) * mu0*(1-mu0) * pi * (1-pi) / (pi * mu1*(1-mu1) + (1-pi) *mu0*(1-mu0) )) * v*V)})
    scale_inv <- solve(scale)
    EIF1 <- (Delta/G)*weights*H_star%*%scale_inv*as.vector(Y-mubar)
    EIF2 <- weights*H_star%*%scale_inv*as.vector(mubar-mu)
    EIF <- EIF1 + EIF2

    var_scaled <- var_initial
    print("variace")
    print(sqrt(diag(var_scaled)))
    #var_scaled <-  scale_inv %*% var_unscaled  %*%  t(scale_inv)

    score <- max(abs(colMeans_safe(EIF1 + EIF2 )))

    print(score)
    if(score <= min(0.5,mean(sqrt(diag(var_scaled))))/n) {
      print("converged")
      converged_flag <- TRUE
      break
    }



  }
  print("SCORE: ")
  print(score)

  # Get coefficients
  denom <- pmax((1-mu1)*(mu0), 1e-8)
  num <- mu1*(1-mu0)
  OR <- num/denom
  logOR <- log(pmax(OR, 1e-8))
  estimates <- as.vector(coef(glm(logOR~V-1, family = gaussian(), data = list(V=V, logOR = logOR ))))



  var_scaled <- var_scaled

  se <- sqrt(diag(var_scaled))
  Zvalue <- abs(sqrt(n) * estimates/se)
  pvalue <- signif(2*(1-pnorm(Zvalue)),5)
  ci <- cbind(estimates,   se/sqrt(n), se ,estimates - 1.96*se/sqrt(n), estimates + 1.96*se/sqrt(n), Zvalue, pvalue)
  colnames(ci) <- c("coefs",   "se/sqrt(n)", "se","lower_CI", "upper_CI", "Z-value", "p-value")
  output <- list(coefs = ci, var_mat = var_scaled, score = score)
  class(output) <- c("spOR","npOddsRatio")

  return(output)



}
